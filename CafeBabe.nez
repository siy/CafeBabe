Program = {(@Use)* @Commons (@Unsafe)* (@Test)* #Program}
Commons = {(@Constant)* (@Type)* (@Extension)* (@Function)* #Commons}
Use = __ 'use' {@QualifiedName (@ImportList)? #Use} Semicolon
Constant = {(@Public)? __ 'const' (__ 'val' / @TypeName) @Name Eq @Expression #Constant} Semicolon
Type = {(@AnnotationRef)* (@Public)? __ 'type' @TypeName Eq (ApiDecl / @AnnotationDecl / @TypeAliasDecl / @CompoundTypeDecl / @TupleDecl / @ClassDecl) #Type}
Extension = {(@Public)? __ 'extend' @TypeName (@ApiRefs)? @ClassBlock #Extension}
Function = {(@AnnotationRef)* (@Public)? @MethodSignature @MethodBody #Function}
Unsafe = __ 'unsafe' BlockStart {@Commons (@Test)* #Unsafe} BlockEnd
Test = __ 'test' BlockStart {@Commons (@Unsafe)* #Test} BlockEnd

ImportList = BlockStart {@NameWithAlias (Comma @NameWithAlias)* #ImportList} BlockEnd
NameWithAlias = {@Name (__ 'as'  @Name)? #NameWithAlias}
AnnotationRef = __ '@' {@Name (LP (@ExpressionList)? RP)? #AnnotationRef}
ExpressionList = {@Expression (Comma @Expression)* #ExpressionList}
TupleDecl = LP {(@TypeName)? (Comma @TypeName)* (@OptionalEllipsis)? #TupleDecl} RP Semicolon
ApiDecl = __ 'api' @CommonApiBody
TypeAliasDecl = {@ArgumentType #TypeAliasDecl} Semicolon
AnnotationDecl = __ 'annotation' {@TypedArgDecl @AnnotationBody #AnnotationDecl}
AnnotationBody = BlockStart {(@Statement)* #AnnotationBody} BlockEnd
CompoundTypeDecl = {(@AndType / @OrType)? (Semicolon / @CommonApiDecl) #CompoundTypeDecl}
AndType = {@TypeName (Comma @TypeName)+ #AndType}
OrType = {@TypeName (BitOr @TypeName)+ #OrType}
OptionalEllipsis = {Comma Ellipsis #OptionalEllipsis}

CommonApiDecl = {(@ApiRefs)? @CommonApiBody #CommonApiDecl}
ApiRefs = Colon {@TypeNameList #ApiRefs}
CommonApiBody = BlockStart { (@Constant)* ((@MethodSignature Semicolon) / @StaticMethodImpl / @DefaultMethodImpl)* (@NamedClassDecl)* #CommonApiBody} BlockEnd
MethodSignature = {(@TypeVarsDecl)? (@TypedFunction/@UntypedFunction) #MethodSignature}
TypedFunction = {@TypeName @Name @TypedArgDecl #TypedFunction}
UntypedFunction = __ 'fn' {@Name @OptionalNameList #UntypedFunction}
OptionalNameList = LP {(@NameList)? #OptionalNameList} RP

ClassDecl = __ 'class' {(@ClassDataDecl)? (@ApiRefs)? (@ClassBlock / Semicolon) #ClassDecl}
NamedClassDecl = {(@Public)? __ 'class' @TypeName @ClassBody #NamedClassDecl}
ClassBody = {(@TypedArgDecl)? (@ApiRefs)? @ClassBlock #ClassBody}
TypedArgDecl = LP {(@TypedArgList)? #TypedArgDecl} RP
ClassDataDecl = LP {(@ClassFields)? #ClassDataDecl} RP
ClassFields = {@ClassField (Comma @ClassField)* (@OptionalEllipsis)? #ClassFields}
ClassField = {(@Mutable)? @TypedArgument #ClassField}
Mutable = {__ 'var' #Mutable}
ClassBlock = BlockStart {(@Constant)* (@Constructor)* (@Destructor)? (@StaticMethodImpl / @Function / @MethodImpl)* (@NamedClassDecl)* #ClassBlock} BlockEnd
StaticMethodImpl = {(@Public)? __ 'static' @MethodSignature @MethodBody #StaticMethodImpl}
DefaultMethodImpl = __ 'default' {@MethodSignature @MethodBody #DefaultMethodImpl}
Constructor = {(@Public)? @Name @TypedArgDecl @MethodBody #Constructor}
Destructor = {(@Public)? __ '#' @Name LP RP @MethodBody #Destructor}
Public = __ {'pub' #Public}

MethodImpl = __ 'impl' {@Name @OptionalNameList @MethodBody #MethodImpl}
MethodBody = {@MethodExpression / @MethodBlockBody #MethodBody}
MethodExpression = Eq {@Expression #MethodExpression} Semicolon

MethodBlockBody = BlockStart {(@Statement)*} BlockEnd
Statement = {@ForStatement / @IfExpression / @SelectExpression / @MatchExpression / @ReturnStatement  / @BreakStatement / @ContinueStatement / @VariableDeclaration / @Assignment / @IterableStatement / @MethodBlockBody / @ValueStatement #Statement}
BreakStatement = __ {'break' #BreakStatement} Semicolon
ContinueStatement = __ {'continue' #ContinueStatement} Semicolon
ValueStatement = {@Value #ValueStatement} Semicolon
VariableDeclaration = {@VarTitle @Assignment #VariableDeclaration}
VarTitle = __ {('val' / 'var' / @TypeName) #VarTitle}
Assignment = {@AssignmentExpr #Assignment} Semicolon
AssignmentExpr = {@RegularAssignment / @ParallelAssignment #AssignmentExpr}
RegularAssignment = {@QualifiedName @AssignOps @Expression #RegularAssignment}
ParallelAssignment = {@RequiredNameList Eq (@TupleConstruction / @Expression) #ParallelAssignment}
TupleConstruction = LP {(@ValueReference)? (@Expression)? (Comma @Expression)* (@OptionalEllipsis)? #TupleConstruction} RP
RequiredNameList = LP {@NameList #RequiredNameList} RP
ForStatement = __ 'for' {@ForSetup @MethodBlockBody #ForStatement}
ForSetup = LP {@VarTitle @Name Colon @Expression #ForSetup} RP
ReturnStatement = __ {'return' (@Expression)? #ReturnStatement} Semicolon
IterableStatement = {@Iterable (@Invoke)* #IterableStatement} Semicolon
Invoke = {@CallParameters / @MethodCall / @Index #Invoke}
MethodCall = {Dot @QualifiedName (@Invoke)? #MethodCall}

TypeName = {@Name (@TypeArguments)? BitAnd? (@ArrayDecl)* #TypeName}
ArrayDecl = LSqB {`[]` #ArrayDecl} RSqB
TypeArguments = LT {@TypeNameList (@OptionalEllipsis)? #TypeArguments} GT
TypeVarsDecl = LT {@LimitedTypeName (Comma @LimitedTypeName)* #TypeVarsDecl} GT
LimitedTypeName = {@Name (Colon @TypeName ('+'/'-')?)? #LimitedTypeName}
TypeNameList = {@TypeName (Comma @TypeName)* #TypeNameList}
TypedArgList = {@TypedArgument (Comma @TypedArgument)* (@OptionalEllipsis)? #TypedArgList}
TypedArgument = {@ArgumentType @Name #TypedArgument}
ArgumentType = {@TypeName (Arrow Ellipsis? @TypeName)* #ArgumentType}
NameList = {@Name (Comma @Name)* #NameList}

Expression = {@IfExpression / @SelectExpression / @MatchExpression / @TernaryExpression / @Expr #Expression}
IfExpression = __ 'if' {@BooleanExpression @MethodBlockBody (__ 'else' @MethodBlockBody)? #IfExpression}

SelectExpression = __ 'select' {@NestedExpr @SelectBody #SelectExpression}
SelectBody = BlockStart {(@SelectCase)* (@Default)? #SelectBody} BlockEnd

MatchExpression = __ 'match' {@NestedExpr @MatchBody #MatchExpression}
MatchBody = BlockStart {(@MatchCase)* (@Default)? #MatchBody} BlockEnd

TernaryExpression = {@NestedExpr QuestMark @Expression Colon @Expression #TernaryExpression}
BooleanExpression = LP {@Expression #BooleanExpression} RP
SelectCase = __ 'case' {CaseExpr Arrow @Expression #SelectCase} Semicolon
MatchCase = {@TypeConstructor Arrow @Expression #MatchCase} Semicolon
Default = __ 'default' Arrow {@Expression #Default} Semicolon
CaseExpr = @NumLiteral / @StringLiteral / @ObjConstruction
TypeConstructor = {@TypeName / @TypeArguments #TypeConstructor}

Expr = {@Or (LogicalOr @Or)* #Expr}
Or = {@And (LogicalAnd @And)* #Or}
And = {@BitwiseOr (BitOr @BitwiseOr)* #And}
BitwiseOr = {@BitwiseXor (BitXor @BitwiseXor)* #BitwiseOr}
BitwiseXor = {@BitwiseAnd (BitAnd @BitwiseAnd)* #BitwiseXor}
BitwiseAnd = {@Equality (EqualityOps @Equality)? #BitwiseAnd}
Equality = {@Compare (@Comparison / @TypeCheck)? #Equality}
Comparison = {CompareOps @Compare #Comparison}
TypeCheck = __ 'isA' {@TypeConstructor #TypeCheck}

Compare = {@Shift (ShiftOps @Shift)* #Compare}
Shift = {@Sum (SumOps @Sum)* #Shift}
Sum = {@Product (MulOps @Product)* #Sum}
Product = {(@Cast / UnaryOps)* (@MethodReference / @Value / @NestedExpr / Ellipsis) #Product}
Cast = LP {@TypeName #Cast} RP
NestedExpr = LP {@Expression #NestedExpr} RP
MethodReference = {(@QualifiedName)? DoubleColon @Name #MethodReference}

Value = {(@ObjConstruction / @ArrayConstruction / @TupleConstruction / @Lambda / @QualifiedName / @Iterable / @LiteralValue) (@Invoke)* (@PostfixOps)? #Value}
LiteralValue = {@NumLiteral / @CharLiteral / @StringLiteral #LiteralValue}
Index = LSqB {@Expression #Index} RSqB
Lambda = {(@SingleParamLambda / @MultiparamLambda) Ellipsis? (@Expression / @MethodBlockBody) #Lambda}
SingleParamLambda = {(@Name Arrow)+ #SingleParamLambda}
MultiparamLambda = {(@TypeName)? @CallParameters #MultiparamLambda} Arrow

CallParameters = {(@TypeArguments)? (@NamedCallParameters/@AnonymousCallParameters) #CallParameters}
NamedCallParameters = LP {@NamedAssignmentList #NamedCallParameters} RP
AnonymousCallParameters = LP {(@ExpressionList (@OptionalEllipsis)?)? #AnonymousCallParameters} RP
ObjConstruction = {(@TypeName)? @ObjConstructionBody #ObjConstruction}
ObjConstructionBody = BlockStart {(@ValueReference)? @NamedAssignmentList #ObjConstructionBody} BlockEnd
NamedAssignmentList = {@NamedAssignment (Comma @NamedAssignment)* #NamedAssignmentList}
NamedAssignment = {@Name Eq @Expression #NamedAssignment}
ValueReference = {@QualifiedName (@Invoke)* #ValueReference} BitOr

ArrayConstruction = LSqB {(@ArrayElements)? #ArrayConstruction}RSqB
ArrayElements = {@ExpressionList #ArrayElements} Comma?
Iterable = {@Comprehension / @OpenRange #Iterable}
OpenRange = {@NumLiteral SequenceSign (@NumLiteral)? #OpenRange}
Comprehension = LSqB {@NamedRange ((Comma / BitOr) @NamedRange)* @ComprPipeline #Comprehension} RSqB
NamedRange = {@Name Colon @OpenRange #NamedRange}
ComprPipeline = Arrow {@Expression (BitOr @Expression)* #ComprPipeline}

SumOps = __ ('+'/'-')
MulOps = __ ('*' / '/' / '%')
UnaryOps = __ ('-' / '+' / '--' / '++' / '!' / '~')
PostfixOps = __ {('--' / '++') #PostfixOps}
AssignOps = __ {(Eq / '+=' / '-=' / '^=' / '|=' / '&=' ) #AssignOps}
EqualityOps = __ ('==' / '!=')
CompareOps = __ ('<=' / '>=' / LT / GT)
ShiftOps = __ ('<<' / '>>' / '>>>')

NumLiteral = {BasedNumLiteral (@NumSuffix)? #NumLiteral}
BasedNumLiteral = @HexNumLiteral / @OctNumLiteral / @BinNumLiteral / @FloatNumLiteral / @DecNumLiteral
HexNumLiteral = __ {'0x' [0-9a-fA-F] [0-9a-fA-F_]* #HexNumLiteral} __
OctNumLiteral = __ {'0o' [0-7] [0-7_]* #OctNumLiteral} __
BinNumLiteral = __ {'0b' [01] [01_]* #BinNumLiteral} __
FloatNumLiteral = __ {DecSegment '.' DecSegment (('e'/'E') ('+' / '-')? DecSegment)? #FloatNumLiteral} __
DecNumLiteral = __ {DecSegment #DecNumLiteral} __
DecSegment = [0-9][0-9_]*

NumSuffix = {'i8' / 'u8' / 'i16' / 'u16' / 'i32' / 'u32' / 'i64' / 'u64' / 'f16' / 'f32' / 'f64' #NumSuffix}

QualifiedName = __ !('F"') {[_$@a-zA-Z] [_$.a-zA-Z0-9]* #QualifiedName} __
Name = __ !('F"') {[_$@a-zA-Z] [_$a-zA-Z0-9]* #Name} __

CharLiteral = __ {[\'] ('\'' / ![\'] .) [\'] #CharLiteral} __

StringLiteral = {@InterpolatedStringLiteral / (@StringSegment)+ #StringLiteral}
StringSegment = __ '"' {('\\"' / !'"' .)* #StringSegment} '"' __
InterpolatedStringLiteral = __ 'F"' {('\\"' / !'"' .)* #InterpolatedStringLiteral} '"' __

Semicolon = __ ';' __
Ellipsis = __ '...'
Arrow = __ '->'
LogicalAnd = __ '&&'
LogicalOr = __ '||'
BitAnd = __ '&'
BitOr = __ '|'
BitXor = __ '^'
Comma = __ ','
BlockStart = __ '{'
BlockEnd = __ '}' __
SequenceSign = __ '..'
LP = __ '('
RP = __ ')'
LSqB = __ '['
RSqB = __ ']'
Dot = __ '.'
Colon = __ ':'
DoubleColon = __ '::'
Eq = __ '='
LT = __ '<'
GT = __ '>'
QuestMark = __ '?'
__ = [ \t\r\n]* Comment?
Comment = '//' (!End .)* &End __?
End = Eol / Eof
Eol = '\r\n' / '\n' / '\r'
Eof = !.
