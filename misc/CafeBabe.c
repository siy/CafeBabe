/* A packrat parser generated by PackCC 1.3.1 */

#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)
static size_t pcc_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* defined __GNUC__ && defined _WIN32 */ 
#endif /* !_MSC_VER */

#include "CafeBabe.h"

#ifndef PCC_BUFFERSIZE
#define PCC_BUFFERSIZE 256
#endif /* !PCC_BUFFERSIZE */

#ifndef PCC_ARRAYSIZE
#define PCC_ARRAYSIZE 2
#endif /* !PCC_ARRAYSIZE */

typedef enum pcc_bool_tag {
    PCC_FALSE = 0,
    PCC_TRUE
} pcc_bool_t;

typedef struct pcc_char_array_tag {
    char *buf;
    int max;
    int len;
} pcc_char_array_t;

typedef struct pcc_range_tag {
    int start;
    int end;
} pcc_range_t;

typedef int pcc_value_t;

typedef void *pcc_auxil_t;

typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    int max;
    int len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    int max;
    int len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    pcc_range_t range;
    char *string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_table_tag {
    pcc_capture_t *buf;
    int max;
    int len;
} pcc_capture_table_t;

typedef struct pcc_capture_const_table_tag {
    const pcc_capture_t **buf;
    int max;
    int len;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;
typedef struct pcc_thunk_array_tag pcc_thunk_array_t;

typedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t values;
    pcc_capture_const_table_t capts;
    pcc_capture_t capt0;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    const pcc_thunk_array_t *thunks; /* just a reference */
    pcc_value_t *value; /* just a reference */
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

struct pcc_thunk_array_tag {
    pcc_thunk_t **buf;
    int max;
    int len;
};

typedef struct pcc_thunk_chunk_tag {
    pcc_value_table_t values;
    pcc_capture_table_t capts;
    pcc_thunk_array_t thunks;
    int pos;
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    int pos;
    pcc_lr_answer_t *hold;
};

typedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *);

typedef struct pcc_rule_set_tag {
    pcc_rule_t *buf;
    int max;
    int len;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    pcc_rule_t rule;
    pcc_rule_set_t invol;
    pcc_rule_set_t eval;
    pcc_lr_head_t *hold;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    pcc_lr_memo_t *buf;
    int max;
    int len;
} pcc_lr_memo_map_t;

typedef struct pcc_lr_table_entry_tag {
    pcc_lr_head_t *head; /* just a reference */
    pcc_lr_memo_map_t memos;
    pcc_lr_answer_t *hold_a;
    pcc_lr_head_t *hold_h;
} pcc_lr_table_entry_t;

typedef struct pcc_lr_table_tag {
    pcc_lr_table_entry_t **buf;
    int max;
    int len;
} pcc_lr_table_t;

struct pcc_lr_entry_tag {
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

typedef struct pcc_lr_stack_tag {
    pcc_lr_entry_t **buf;
    int max;
    int len;
} pcc_lr_stack_t;

struct pcc_context_tag {
    int pos;
    pcc_char_array_t buffer;
    pcc_lr_table_t lrtable;
    pcc_lr_stack_t lrstack;
    pcc_auxil_t auxil;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) getchar()
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_FREE
#define PCC_FREE(auxil, ptr) free(ptr)
#endif /* !PCC_FREE */

static char *pcc_strndup_e(pcc_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PCC_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void pcc_char_array__init(pcc_auxil_t auxil, pcc_char_array_t *array, int max) {
    array->len = 0;
    array->max = max;
    array->buf = (char *)PCC_MALLOC(auxil, array->max);
}

static void pcc_char_array__add(pcc_auxil_t auxil, pcc_char_array_t *array, char ch) {
    if (array->max <= 0) array->max = 1;
    while (array->max <= array->len) array->max <<= 1;
    array->buf = (char *)PCC_REALLOC(auxil, array->buf, array->max);
    array->buf[array->len++] = ch;
}

static void pcc_char_array__term(pcc_auxil_t auxil, pcc_char_array_t *array) {
    PCC_FREE(auxil, array->buf);
}

static void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table, int max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_value_t *)PCC_MALLOC(auxil, table->max * sizeof(pcc_value_t));
}

static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, int len) {
    if (table->max < len) {
        if (table->max <= 0) table->max = 1;
        while (table->max < len) table->max <<= 1;
        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, table->max * sizeof(pcc_value_t));
    }
    table->len = len;
}

static void pcc_value_table__term(pcc_auxil_t auxil, pcc_value_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table, int max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_value_t **)PCC_MALLOC(auxil, table->max * sizeof(pcc_value_t *));
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, int len) {
    int i;
    if (table->max < len) {
        if (table->max <= 0) table->max = 1;
        while (table->max < len) table->max <<= 1;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, table->max * sizeof(pcc_value_t *));
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_value_refer_table__term(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture_table__init(pcc_auxil_t auxil, pcc_capture_table_t *table, int max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_capture_t *)PCC_MALLOC(auxil, table->max * sizeof(pcc_capture_t));
}

static void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *table, int len) {
    int i;
    for (i = table->len - 1; i >= len; i--) PCC_FREE(auxil, table->buf[i].string);
    if (table->max < len) {
        if (table->max <= 0) table->max = 1;
        while (table->max < len) table->max <<= 1;
        table->buf = (pcc_capture_t *)PCC_REALLOC(auxil, table->buf, table->max * sizeof(pcc_capture_t));
    }
    for (i = table->len; i < len; i++) {
        table->buf[i].range.start = 0;
        table->buf[i].range.end = 0;
        table->buf[i].string = NULL;
    }
    table->len = len;
}

static void pcc_capture_table__term(pcc_auxil_t auxil, pcc_capture_table_t *table) {
    int i;
    for (i = table->len - 1; i >= 0; i--) PCC_FREE(auxil, table->buf[i].string);
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture_const_table__init(pcc_auxil_t auxil, pcc_capture_const_table_t *table, int max) {
    table->len = 0;
    table->max = max;
    table->buf = (const pcc_capture_t **)PCC_MALLOC(auxil, table->max * sizeof(const pcc_capture_t *));
}

static void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *table, int len) {
    int i;
    if (table->max < len) {
        if (table->max <= 0) table->max = 1;
        while (table->max < len) table->max <<= 1;
        table->buf = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)table->buf, table->max * sizeof(const pcc_capture_t *));
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_capture_const_table__term(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, pcc_action_t action, int valuec, int captc) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));
    thunk->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__init(auxil, &thunk->data.leaf.values, valuec);
    pcc_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);
    pcc_capture_const_table__init(auxil, &thunk->data.leaf.capts, captc);
    pcc_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);
    thunk->data.leaf.capt0.range.start = 0;
    thunk->data.leaf.capt0.range.end = 0;
    thunk->data.leaf.capt0.string = NULL;
    thunk->data.leaf.action = action;
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));
    thunk->type = PCC_THUNK_NODE;
    thunk->data.node.thunks = thunks;
    thunk->data.node.value = value;
    return thunk;
}

static void pcc_thunk__destroy(pcc_auxil_t auxil, pcc_thunk_t *thunk) {
    if (thunk == NULL) return;
    switch (thunk->type) {
    case PCC_THUNK_LEAF:
        PCC_FREE(auxil, thunk->data.leaf.capt0.string);
        pcc_capture_const_table__term(auxil, &thunk->data.leaf.capts);
        pcc_value_refer_table__term(auxil, &thunk->data.leaf.values);
        break;
    case PCC_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    PCC_FREE(auxil, thunk);
}

static void pcc_thunk_array__init(pcc_auxil_t auxil, pcc_thunk_array_t *array, int max) {
    array->len = 0;
    array->max = max;
    array->buf = (pcc_thunk_t **)PCC_MALLOC(auxil, array->max * sizeof(pcc_thunk_t *));
}

static void pcc_thunk_array__add(pcc_auxil_t auxil, pcc_thunk_array_t *array, pcc_thunk_t *thunk) {
    if (array->max <= 0) array->max = 1;
    while (array->max <= array->len) array->max <<= 1;
    array->buf = (pcc_thunk_t **)PCC_REALLOC(auxil, array->buf, array->max * sizeof(pcc_thunk_t *));
    array->buf[array->len++] = thunk;
}

static void pcc_thunk_array__revert(pcc_auxil_t auxil, pcc_thunk_array_t *array, int len) {
    while (array->len > len) {
        array->len--;
        pcc_thunk__destroy(auxil, array->buf[array->len]);
    }
}

static void pcc_thunk_array__term(pcc_auxil_t auxil, pcc_thunk_array_t *array) {
    int i;
    for (i = array->len - 1; i >= 0; i--) pcc_thunk__destroy(auxil, array->buf[i]);
    PCC_FREE(auxil, array->buf);
}

static pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_auxil_t auxil) {
    pcc_thunk_chunk_t *const chunk = (pcc_thunk_chunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_chunk_t));
    pcc_value_table__init(auxil, &chunk->values, PCC_ARRAYSIZE);
    pcc_capture_table__init(auxil, &chunk->capts, PCC_ARRAYSIZE);
    pcc_thunk_array__init(auxil, &chunk->thunks, PCC_ARRAYSIZE);
    chunk->pos = 0;
    return chunk;
}

static void pcc_thunk_chunk__destroy(pcc_auxil_t auxil, pcc_thunk_chunk_t *chunk) {
    if (chunk == NULL) return;
    pcc_thunk_array__term(auxil, &chunk->thunks);
    pcc_capture_table__term(auxil, &chunk->capts);
    pcc_value_table__term(auxil, &chunk->values);
    PCC_FREE(auxil, chunk);
}

static void pcc_rule_set__init(pcc_auxil_t auxil, pcc_rule_set_t *set, int max) {
    set->len = 0;
    set->max = max;
    set->buf = (pcc_rule_t *)PCC_MALLOC(auxil, set->max * sizeof(pcc_rule_t));
}

static int pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *set, pcc_rule_t rule) {
    int i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return -1;
}

static pcc_bool_t pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const int i = pcc_rule_set__index(auxil, set, rule);
    if (i >= 0) return PCC_FALSE;
    if (set->max <= 0) set->max = 1;
    while (set->max <= set->len) set->max <<= 1;
    set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, set->max * sizeof(pcc_rule_t));
    set->buf[set->len++] = rule;
    return PCC_TRUE;
}

static pcc_bool_t pcc_rule_set__remove(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const int i = pcc_rule_set__index(auxil, set, rule);
    if (i < 0) return PCC_FALSE;
    memmove(set->buf + i, set->buf + (i + 1), (set->len - (i + 1)) * sizeof(pcc_rule_t));
    return PCC_TRUE;
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, pcc_rule_set_t *set, const pcc_rule_set_t *src) {
    int i;
    pcc_rule_set__clear(auxil, set);
    for (i = 0; i < src->len; i++) {
        pcc_rule_set__add(auxil, set, src->buf[i]);
    }
}

static void pcc_rule_set__term(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    PCC_FREE(auxil, set->buf);
}

static pcc_lr_head_t *pcc_lr_head__create(pcc_auxil_t auxil, pcc_rule_t rule) {
    pcc_lr_head_t *const head = (pcc_lr_head_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_head_t));
    head->rule = rule;
    pcc_rule_set__init(auxil, &head->invol, PCC_ARRAYSIZE);
    pcc_rule_set__init(auxil, &head->eval, PCC_ARRAYSIZE);
    head->hold = NULL;
    return head;
}

static void pcc_lr_head__destroy(pcc_auxil_t auxil, pcc_lr_head_t *head) {
    if (head == NULL) return;
    pcc_lr_head__destroy(auxil, head->hold);
    pcc_rule_set__term(auxil, &head->eval);
    pcc_rule_set__term(auxil, &head->invol);
    PCC_FREE(auxil, head);
}

static void pcc_lr_entry__destroy(pcc_auxil_t auxil, pcc_lr_entry_t *lr);

static pcc_lr_answer_t *pcc_lr_answer__create(pcc_auxil_t auxil, pcc_lr_answer_type_t type, int pos) {
    pcc_lr_answer_t *answer = (pcc_lr_answer_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_answer_t));
    answer->type = type;
    answer->pos = pos;
    answer->hold = NULL;
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        answer->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        answer->data.chunk = NULL;
        break;
    default: /* unknown */
        PCC_FREE(auxil, answer);
        answer = NULL;
    }
    return answer;
}

static void pcc_lr_answer__set_chunk(pcc_auxil_t auxil, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *const a = pcc_lr_answer__create(auxil, answer->type, answer->pos);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = answer->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = answer->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    a->hold = answer->hold;
    answer->hold = a;
    answer->type = PCC_LR_ANSWER_CHUNK;
    answer->data.chunk = chunk;
}

static void pcc_lr_answer__destroy(pcc_auxil_t auxil, pcc_lr_answer_t *answer) {
    if (answer == NULL) return;
    pcc_lr_answer__destroy(auxil, answer->hold);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        pcc_lr_entry__destroy(auxil, answer->data.lr);
        break;
    case PCC_LR_ANSWER_CHUNK:
        pcc_thunk_chunk__destroy(auxil, answer->data.chunk);
        break;
    default: /* unknown */
        break;
    }
    PCC_FREE(auxil, answer);
}

static void pcc_lr_memo_map__init(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, int max) {
    map->len = 0;
    map->max = max;
    map->buf = (pcc_lr_memo_t *)PCC_MALLOC(auxil, map->max * sizeof(pcc_lr_memo_t));
}

static int pcc_lr_memo_map__index(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    int i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return -1;
}

static void pcc_lr_memo_map__put(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    const int i = pcc_lr_memo_map__index(auxil, map, rule);
    if (i >= 0) {
        pcc_lr_answer__destroy(auxil, map->buf[i].answer);
        map->buf[i].answer = answer;
    }
    else {
        if (map->max <= 0) map->max = 1;
        while (map->max <= map->len) map->max <<= 1;
        map->buf = (pcc_lr_memo_t *)PCC_REALLOC(auxil, map->buf, map->max * sizeof(pcc_lr_memo_t));
        map->buf[map->len].rule = rule;
        map->buf[map->len].answer = answer;
        map->len++;
    }
}

static pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_auxil_t auxil, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    const int i = pcc_lr_memo_map__index(auxil, map, rule);
    return (i >= 0) ? map->buf[i].answer : NULL;
}

static void pcc_lr_memo_map__term(pcc_auxil_t auxil, pcc_lr_memo_map_t *map) {
    int i;
    for (i = map->len - 1; i >= 0; i--) pcc_lr_answer__destroy(auxil, map->buf[i].answer);
    PCC_FREE(auxil, map->buf);
}

static pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_auxil_t auxil) {
    pcc_lr_table_entry_t *const entry = (pcc_lr_table_entry_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_table_entry_t));
    entry->head = NULL;
    pcc_lr_memo_map__init(auxil, &entry->memos, PCC_ARRAYSIZE);
    entry->hold_a = NULL;
    entry->hold_h = NULL;
    return entry;
}

static void pcc_lr_table_entry__destroy(pcc_auxil_t auxil, pcc_lr_table_entry_t *entry) {
    if (entry == NULL) return;
    pcc_lr_head__destroy(auxil, entry->hold_h);
    pcc_lr_answer__destroy(auxil, entry->hold_a);
    pcc_lr_memo_map__term(auxil, &entry->memos);
    PCC_FREE(auxil, entry);
}

static void pcc_lr_table__init(pcc_auxil_t auxil, pcc_lr_table_t *table, int max) {
    table->len = 0;
    table->max = max;
    table->buf = (pcc_lr_table_entry_t **)PCC_MALLOC(auxil, table->max * sizeof(pcc_lr_table_entry_t *));
}

static void pcc_lr_table__resize(pcc_auxil_t auxil, pcc_lr_table_t *table, int len) {
    int i;
    for (i = table->len - 1; i >= len; i--) pcc_lr_table_entry__destroy(auxil, table->buf[i]);
    if (table->max < len) {
        if (table->max <= 0) table->max = 1;
        while (table->max < len) table->max <<= 1;
        table->buf = (pcc_lr_table_entry_t **)PCC_REALLOC(auxil, table->buf, table->max * sizeof(pcc_lr_table_entry_t *));
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_lr_table__set_head(pcc_auxil_t auxil, pcc_lr_table_t *table, int index, pcc_lr_head_t *head) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    table->buf[index]->head = head;
}

static void pcc_lr_table__hold_head(pcc_auxil_t auxil, pcc_lr_table_t *table, int index, pcc_lr_head_t *head) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    head->hold = table->buf[index]->hold_h;
    table->buf[index]->hold_h = head;
}

static void pcc_lr_table__set_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, int index, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    pcc_lr_memo_map__put(auxil, &table->buf[index]->memos, rule, answer);
}

static void pcc_lr_table__hold_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, int index, pcc_lr_answer_t *answer) {
    if (index >= table->len) pcc_lr_table__resize(auxil, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(auxil);
    answer->hold = table->buf[index]->hold_a;
    table->buf[index]->hold_a = answer;
}

static pcc_lr_head_t *pcc_lr_table__get_head(pcc_auxil_t auxil, pcc_lr_table_t *table, int index) {
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return table->buf[index]->head;
}

static pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_auxil_t auxil, pcc_lr_table_t *table, int index, pcc_rule_t rule) {
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return pcc_lr_memo_map__get(auxil, &table->buf[index]->memos, rule);
}

static void pcc_lr_table__shift(pcc_auxil_t auxil, pcc_lr_table_t *table, int count) {
    int i;
    if (count > table->len) count = table->len;
    for (i = 0; i < count; i++) pcc_lr_table_entry__destroy(auxil, table->buf[i]);
    memmove(table->buf, table->buf + count, (table->len - count) * sizeof(pcc_lr_table_entry_t *));
    table->len -= count;
}

static void pcc_lr_table__term(pcc_auxil_t auxil, pcc_lr_table_t *table) {
    int i;
    for (i = table->len - 1; i >= 0; i--) pcc_lr_table_entry__destroy(auxil, table->buf[i]);
    PCC_FREE(auxil, table->buf);
}

static pcc_lr_entry_t *pcc_lr_entry__create(pcc_auxil_t auxil, pcc_rule_t rule) {
    pcc_lr_entry_t *const lr = (pcc_lr_entry_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_entry_t));
    lr->rule = rule;
    lr->seed = NULL;
    lr->head = NULL;
    return lr;
}

static void pcc_lr_entry__destroy(pcc_auxil_t auxil, pcc_lr_entry_t *lr) {
    PCC_FREE(auxil, lr);
}

static void pcc_lr_stack__init(pcc_auxil_t auxil, pcc_lr_stack_t *stack, int max) {
    stack->len = 0;
    stack->max = max;
    stack->buf = (pcc_lr_entry_t **)PCC_MALLOC(auxil, stack->max * sizeof(pcc_lr_entry_t *));
}

static void pcc_lr_stack__push(pcc_auxil_t auxil, pcc_lr_stack_t *stack, pcc_lr_entry_t *lr) {
    if (stack->max <= 0) stack->max = 1;
    while (stack->max <= stack->len) stack->max <<= 1;
    stack->buf = (pcc_lr_entry_t **)PCC_REALLOC(auxil, stack->buf, stack->max * sizeof(pcc_lr_entry_t *));
    stack->buf[stack->len++] = lr;
}

static pcc_lr_entry_t *pcc_lr_stack__pop(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    return stack->buf[--stack->len];
}

static void pcc_lr_stack__term(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    PCC_FREE(auxil, stack->buf);
}

static pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {
    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));
    ctx->pos = 0;
    pcc_char_array__init(auxil, &ctx->buffer, PCC_BUFFERSIZE);
    pcc_lr_table__init(auxil, &ctx->lrtable, PCC_BUFFERSIZE);
    pcc_lr_stack__init(auxil, &ctx->lrstack, PCC_ARRAYSIZE);
    ctx->auxil = auxil;
    return ctx;
}

static void pcc_context__destroy(pcc_context_t *ctx) {
    if (ctx == NULL) return;
    pcc_lr_stack__term(ctx->auxil, &ctx->lrstack);
    pcc_lr_table__term(ctx->auxil, &ctx->lrtable);
    pcc_char_array__term(ctx->auxil, &ctx->buffer);
    PCC_FREE(ctx->auxil, ctx);
}

static int pcc_refill_buffer(pcc_context_t *ctx, int num) {
    int n, c;
    n = ctx->buffer.len - ctx->pos;
    if (n >= num) return n;
    while (ctx->buffer.len < ctx->pos + num) {
        c = PCC_GETCHAR(ctx->auxil);
        if (c == EOF) break;
        pcc_char_array__add(ctx->auxil, &ctx->buffer, (char)c);
    }
    return ctx->buffer.len - ctx->pos;
}

static void pcc_commit_buffer(pcc_context_t *ctx) {
    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->pos, ctx->buffer.len - ctx->pos);
    ctx->buffer.len -= ctx->pos;
    pcc_lr_table__shift(ctx->auxil, &ctx->lrtable, ctx->pos);
    ctx->pos = 0;
}

static const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {
    if (capt->string == NULL)
        ((pcc_capture_t *)capt)->string =
            pcc_strndup_e(ctx->auxil, ctx->buffer.buf + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

static pcc_bool_t pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, pcc_thunk_array_t *thunks, pcc_value_t *value) {
    static pcc_value_t null;
    pcc_thunk_chunk_t *c = NULL;
    const int p = ctx->pos;
    pcc_bool_t b = PCC_TRUE;
    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx->auxil, &ctx->lrtable, p, rule);
    pcc_lr_head_t *h = pcc_lr_table__get_head(ctx->auxil, &ctx->lrtable, p);
    if (h != NULL) {
        if (a == NULL && rule != h->rule && pcc_rule_set__index(ctx->auxil, &h->invol, rule) < 0) {
            b = PCC_FALSE;
            c = NULL;
        }
        else if (pcc_rule_set__remove(ctx->auxil, &h->eval, rule)) {
            b = PCC_FALSE;
            c = rule(ctx);
            a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_CHUNK, ctx->pos);
            a->data.chunk = c;
            pcc_lr_table__hold_answer(ctx->auxil, &ctx->lrtable, p, a);
        }
    }
    if (b) {
        if (a != NULL) {
            ctx->pos = a->pos;
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    a->data.lr->head = pcc_lr_head__create(ctx->auxil, rule);
                    pcc_lr_table__hold_head(ctx->auxil, &ctx->lrtable, p, a->data.lr->head);
                }
                {
                    int i;
                    for (i = ctx->lrstack.len - 1; i >= 0; i--) {
                        if (ctx->lrstack.buf[i]->head == a->data.lr->head) break;
                        ctx->lrstack.buf[i]->head = a->data.lr->head;
                        pcc_rule_set__add(ctx->auxil, &a->data.lr->head->invol, ctx->lrstack.buf[i]->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            pcc_lr_entry_t *const e = pcc_lr_entry__create(ctx->auxil, rule);
            pcc_lr_stack__push(ctx->auxil, &ctx->lrstack, e);
            a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_LR, p);
            a->data.lr = e;
            pcc_lr_table__set_answer(ctx->auxil, &ctx->lrtable, p, rule, a);
            c = rule(ctx);
            pcc_lr_stack__pop(ctx->auxil, &ctx->lrstack);
            a->pos = ctx->pos;
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(ctx->auxil, a, c);
            }
            else {
                e->seed = c;
                h = a->data.lr->head;
                if (h->rule != rule) {
                    c = a->data.lr->seed;
                    a = pcc_lr_answer__create(ctx->auxil, PCC_LR_ANSWER_CHUNK, ctx->pos);
                    a->data.chunk = c;
                    pcc_lr_table__hold_answer(ctx->auxil, &ctx->lrtable, p, a);
                }
                else {
                    pcc_lr_answer__set_chunk(ctx->auxil, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        pcc_lr_table__set_head(ctx->auxil, &ctx->lrtable, p, h);
                        for (;;) {
                            ctx->pos = p;
                            pcc_rule_set__copy(ctx->auxil, &h->eval, &h->invol);
                            c = rule(ctx);
                            if (c == NULL || ctx->pos <= a->pos) break;
                            pcc_lr_answer__set_chunk(ctx->auxil, a, c);
                            a->pos = ctx->pos;
                        }
                        pcc_thunk_chunk__destroy(ctx->auxil, c);
                        pcc_lr_table__set_head(ctx->auxil, &ctx->lrtable, p, NULL);
                        ctx->pos = a->pos;
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return PCC_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(pcc_value_t)); /* in case */
    pcc_thunk_array__add(ctx->auxil, thunks, pcc_thunk__create_node(ctx->auxil, &c->thunks, value));
    return PCC_TRUE;
}

static void pcc_do_action(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    int i;
    for (i = 0; i < thunks->len; i++) {
        pcc_thunk_t *const thunk = thunks->buf[i];
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PCC_THUNK_NODE:
            pcc_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Program(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Commons(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Use(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Constant(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Type(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Extension(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Function(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Unsafe(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Test(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NameWithAlias(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationRef(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExpressionList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TupleDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ApiDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeAliasDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CompoundTypeDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AndType(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OrType(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OptionalEllipsis(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CommonApiDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ApiRefs(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CommonApiBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodSignature(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedFunction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UntypedFunction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OptionalNameList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedClassDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDataDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassFields(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassField(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Mutable(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassBlock(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StaticMethodImpl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefaultMethodImpl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Constructor(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Destructor(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Public(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodImpl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodBlockBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Statement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BreakStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ContinueStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ValueStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VariableDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VarTitle(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Assignment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignmentExpr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RegularAssignment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ParallelAssignment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TupleConstruction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequiredNameList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ForStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ForSetup(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IterableStatement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Invoke(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodCall(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeArguments(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeVarsDecl(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LimitedTypeName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeNameList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgument(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentType(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NameList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Expression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IfExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TernaryExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BooleanExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectCase(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchCase(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Default(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseExpr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeConstructor(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Expr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Or(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_And(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseOr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseXor(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseAnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Equality(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comparison(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeCheck(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Compare(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Shift(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Sum(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Product(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Cast(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NestedExpr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodReference(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Value(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralValue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Index(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Lambda(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SingleParamLambda(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiparamLambda(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CallParameters(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedCallParameters(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnonymousCallParameters(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjConstruction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjConstructionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedAssignmentList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedAssignment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ValueReference(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayConstruction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayElements(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Iterable(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OpenRange(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comprehension(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedRange(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ComprPipeline(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SumOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MulOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PostfixOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CompareOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ShiftOps(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BasedNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_HexNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OctNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BinNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FloatNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DecNumLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DecSegment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NumSuffix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_QualifiedName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Name(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CharLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StringLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StringSegment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterpolatedStringLiteral(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Semicolon(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Ellipsis(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Arrow(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LogicalAnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LogicalOr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitAnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitOr(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BitXor(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comma(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BlockStart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BlockEnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LSqB(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RSqB(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Colon(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule___(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_end(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_eol(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_eof(pcc_context_t *ctx);

static pcc_thunk_chunk_t *pcc_evaluate_rule_Program(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Use, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Commons, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Unsafe, &chunk->thunks, NULL)) goto L0004;
            if (ctx->pos == p) break;
            continue;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Test, &chunk->thunks, NULL)) goto L0005;
            if (ctx->pos == p) break;
            continue;
        L0005:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_eof, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Commons(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Constant, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Type, &chunk->thunks, NULL)) goto L0002;
            if (ctx->pos == p) break;
            continue;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Extension, &chunk->thunks, NULL)) goto L0003;
            if (ctx->pos == p) break;
            continue;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Function, &chunk->thunks, NULL)) goto L0004;
            if (ctx->pos == p) break;
            continue;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Use(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[1] != 's' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'e'
    ) goto L0000;
    ctx->pos += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImportList, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Constant(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 5) < 5 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'o' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[3] != 's' ||
        (ctx->buffer.buf + ctx->pos)[4] != 't'
    ) goto L0000;
    ctx->pos += 5;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0004;
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'v' ||
            (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
            (ctx->buffer.buf + ctx->pos)[2] != 'l'
        ) goto L0004;
        ctx->pos += 3;
        goto L0003;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '='
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Type(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotationRef, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 4) < 4 ||
        (ctx->buffer.buf + ctx->pos)[0] != 't' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'y' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'p' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'e'
    ) goto L0000;
    ctx->pos += 4;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '='
    ) goto L0000;
    ctx->pos++;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ApiDecl, &chunk->thunks, NULL)) goto L0005;
        goto L0004;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotationDecl, &chunk->thunks, NULL)) goto L0006;
        goto L0004;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeAliasDecl, &chunk->thunks, NULL)) goto L0007;
        goto L0004;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CompoundTypeDecl, &chunk->thunks, NULL)) goto L0008;
        goto L0004;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TupleDecl, &chunk->thunks, NULL)) goto L0009;
        goto L0004;
    L0009:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassDecl, &chunk->thunks, NULL)) goto L0010;
        goto L0004;
    L0010:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0004:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Extension(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 6) < 6 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'x' ||
        (ctx->buffer.buf + ctx->pos)[2] != 't' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'd'
    ) goto L0000;
    ctx->pos += 6;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ApiRefs, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassBlock, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Function(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotationRef, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodSignature, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Unsafe(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 6) < 6 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[2] != 's' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'f' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'e'
    ) goto L0000;
    ctx->pos += 6;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Commons, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Test, &chunk->thunks, NULL)) goto L0003;
            if (ctx->pos == p) break;
            continue;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Test(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 4) < 4 ||
        (ctx->buffer.buf + ctx->pos)[0] != 't' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[2] != 's' ||
        (ctx->buffer.buf + ctx->pos)[3] != 't'
    ) goto L0000;
    ctx->pos += 4;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Commons, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Unsafe, &chunk->thunks, NULL)) goto L0003;
            if (ctx->pos == p) break;
            continue;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameWithAlias, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameWithAlias, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NameWithAlias(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0001;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'a' ||
            (ctx->buffer.buf + ctx->pos)[1] != 's'
        ) goto L0001;
        ctx->pos += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationRef(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '@'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0001;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExpressionList, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0003:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0001;
        goto L0004;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExpressionList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TupleDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0003;
            if (ctx->pos == p) break;
            continue;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ApiDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'p' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'i'
    ) goto L0000;
    ctx->pos += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CommonApiBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeAliasDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentType, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 10) < 10 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'o' ||
        (ctx->buffer.buf + ctx->pos)[4] != 't' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[6] != 't' ||
        (ctx->buffer.buf + ctx->pos)[7] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[8] != 'o' ||
        (ctx->buffer.buf + ctx->pos)[9] != 'n'
    ) goto L0000;
    ctx->pos += 10;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgDecl, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotationBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotationBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Statement, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CompoundTypeDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndType, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrType, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0005;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0005:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0007;
        goto L0006;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CommonApiDecl, &chunk->thunks, NULL)) goto L0008;
        goto L0006;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0006:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AndType(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    {
        const int p0 = ctx->pos;
        const int n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->pos = p0;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OrType(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    {
        const int p0 = ctx->pos;
        const int n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitOr, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->pos = p0;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OptionalEllipsis(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ellipsis, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CommonApiDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ApiRefs, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CommonApiBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ApiRefs(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Colon, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeNameList, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CommonApiBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Constant, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodSignature, &chunk->thunks, NULL)) goto L0004;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0004;
                goto L0003;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StaticMethodImpl, &chunk->thunks, NULL)) goto L0005;
                goto L0003;
            L0005:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefaultMethodImpl, &chunk->thunks, NULL)) goto L0006;
                goto L0003;
            L0006:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0002;
            L0003:;
            }
            if (ctx->pos == p) break;
            continue;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedClassDecl, &chunk->thunks, NULL)) goto L0007;
            if (ctx->pos == p) break;
            continue;
        L0007:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodSignature(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeVarsDecl, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedFunction, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UntypedFunction, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedFunction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgDecl, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UntypedFunction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'f' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'n'
    ) goto L0000;
    ctx->pos += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalNameList, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OptionalNameList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameList, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 5) < 5 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'l' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[3] != 's' ||
        (ctx->buffer.buf + ctx->pos)[4] != 's'
    ) goto L0000;
    ctx->pos += 5;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassDataDecl, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ApiRefs, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassBlock, &chunk->thunks, NULL)) goto L0006;
        goto L0005;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0007;
        goto L0005;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0005:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedClassDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 5) < 5 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'l' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[3] != 's' ||
        (ctx->buffer.buf + ctx->pos)[4] != 's'
    ) goto L0000;
    ctx->pos += 5;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgDecl, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ApiRefs, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassBlock, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgList, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDataDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassFields, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassFields(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassField, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassField, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassField(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Mutable, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgument, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Mutable(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'v' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'r'
    ) goto L0000;
    ctx->pos += 3;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassBlock(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Constant, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Constructor, &chunk->thunks, NULL)) goto L0002;
            if (ctx->pos == p) break;
            continue;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Destructor, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StaticMethodImpl, &chunk->thunks, NULL)) goto L0007;
                goto L0006;
            L0007:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Function, &chunk->thunks, NULL)) goto L0008;
                goto L0006;
            L0008:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodImpl, &chunk->thunks, NULL)) goto L0009;
                goto L0006;
            L0009:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0005;
            L0006:;
            }
            if (ctx->pos == p) break;
            continue;
        L0005:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedClassDecl, &chunk->thunks, NULL)) goto L0010;
            if (ctx->pos == p) break;
            continue;
        L0010:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StaticMethodImpl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 6) < 6 ||
        (ctx->buffer.buf + ctx->pos)[0] != 's' ||
        (ctx->buffer.buf + ctx->pos)[1] != 't' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[3] != 't' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'c'
    ) goto L0000;
    ctx->pos += 6;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodSignature, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefaultMethodImpl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 7) < 7 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'd' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'f' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'l' ||
        (ctx->buffer.buf + ctx->pos)[6] != 't'
    ) goto L0000;
    ctx->pos += 7;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodSignature, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Constructor(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgDecl, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Destructor(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Public, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '#'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Public(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'p' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'b'
    ) goto L0000;
    ctx->pos += 3;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodImpl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 4) < 4 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'm' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'p' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'l'
    ) goto L0000;
    ctx->pos += 4;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalNameList, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodExpression, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '='
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodBlockBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Statement, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Statement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForStatement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfExpression, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectExpression, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MatchExpression, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnStatement, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BreakStatement, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ContinueStatement, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariableDeclaration, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Assignment, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IterableStatement, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ValueStatement, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BreakStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 5) < 5 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'b' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'r' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'k'
    ) goto L0000;
    ctx->pos += 5;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ContinueStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 8) < 8 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'o' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[3] != 't' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'n' ||
        (ctx->buffer.buf + ctx->pos)[6] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[7] != 'e'
    ) goto L0000;
    ctx->pos += 8;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ValueStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Value, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VariableDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VarTitle, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Assignment, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VarTitle(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'v' ||
            (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
            (ctx->buffer.buf + ctx->pos)[2] != 'l'
        ) goto L0002;
        ctx->pos += 3;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'v' ||
            (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
            (ctx->buffer.buf + ctx->pos)[2] != 'r'
        ) goto L0003;
        ctx->pos += 3;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Assignment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentExpr, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignmentExpr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RegularAssignment, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParallelAssignment, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RegularAssignment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignOps, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ParallelAssignment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequiredNameList, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '='
    ) goto L0000;
    ctx->pos++;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TupleConstruction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TupleConstruction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ValueReference, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0005;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0005;
            if (ctx->pos == p) break;
            continue;
        L0005:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0006;
        goto L0007;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0007:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequiredNameList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameList, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ForStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'f' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'o' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'r'
    ) goto L0000;
    ctx->pos += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForSetup, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ForSetup(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VarTitle, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Colon, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 6) < 6 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'r' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[2] != 't' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'r' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'n'
    ) goto L0000;
    ctx->pos += 6;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IterableStatement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Iterable, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Invoke, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Invoke(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CallParameters, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodCall, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Index, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodCall(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '.'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Invoke, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeArguments, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitAnd, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArrayDecl, &chunk->thunks, NULL)) goto L0005;
            if (ctx->pos == p) break;
            continue;
        L0005:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LSqB, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RSqB, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeArguments(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '<'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeNameList, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '>'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeVarsDecl(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '<'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LimitedTypeName, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LimitedTypeName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '>'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LimitedTypeName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Colon, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.buf[ctx->pos] != '+'
                ) goto L0004;
                ctx->pos++;
                goto L0003;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.buf[ctx->pos] != '-'
                ) goto L0005;
                ctx->pos++;
                goto L0003;
            L0005:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0002;
            L0003:;
            }
            goto L0006;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0006:;
        }
        goto L0007;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0007:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeNameList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgument, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedArgument, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedArgument(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentType, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentType(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0001;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ellipsis, &chunk->thunks, NULL)) goto L0002;
                goto L0003;
            L0002:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            L0003:;
            }
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NameList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Expression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfExpression, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectExpression, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MatchExpression, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TernaryExpression, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expr, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IfExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'f'
    ) goto L0000;
    ctx->pos += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BooleanExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0001;
        if (
            pcc_refill_buffer(ctx, 4) < 4 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'e' ||
            (ctx->buffer.buf + ctx->pos)[1] != 'l' ||
            (ctx->buffer.buf + ctx->pos)[2] != 's' ||
            (ctx->buffer.buf + ctx->pos)[3] != 'e'
        ) goto L0001;
        ctx->pos += 4;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 6) < 6 ||
        (ctx->buffer.buf + ctx->pos)[0] != 's' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'l' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[5] != 't'
    ) goto L0000;
    ctx->pos += 6;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NestedExpr, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectCase, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Default, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 5) < 5 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'm' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[2] != 't' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'h'
    ) goto L0000;
    ctx->pos += 5;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NestedExpr, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MatchBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MatchCase, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Default, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TernaryExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NestedExpr, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '?'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Colon, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BooleanExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectCase(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 4) < 4 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'c' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[2] != 's' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'e'
    ) goto L0000;
    ctx->pos += 4;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseExpr, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MatchCase(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeConstructor, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Default(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 7) < 7 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'd' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'e' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'f' ||
        (ctx->buffer.buf + ctx->pos)[3] != 'a' ||
        (ctx->buffer.buf + ctx->pos)[4] != 'u' ||
        (ctx->buffer.buf + ctx->pos)[5] != 'l' ||
        (ctx->buffer.buf + ctx->pos)[6] != 't'
    ) goto L0000;
    ctx->pos += 7;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Semicolon, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseExpr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NumLiteral, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StringLiteral, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ObjConstruction, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeConstructor(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeArguments, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Expr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Or, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LogicalOr, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Or, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Or(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_And, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LogicalAnd, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_And, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_And(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseOr, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitOr, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseOr, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseOr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseXor, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitXor, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseXor, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseXor(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseAnd, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitAnd, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitwiseAnd, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitwiseAnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Equality, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityOps, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Equality, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Equality(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Compare, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comparison, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeCheck, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0005;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0005:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comparison(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CompareOps, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Compare, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeCheck(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
        (ctx->buffer.buf + ctx->pos)[1] != 's' ||
        (ctx->buffer.buf + ctx->pos)[2] != 'A'
    ) goto L0000;
    ctx->pos += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeConstructor, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Compare(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Shift, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShiftOps, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Shift, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Shift(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Sum, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SumOps, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Sum, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Sum(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Product, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MulOps, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Product, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Product(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Cast, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryOps, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodReference, &chunk->thunks, NULL)) goto L0006;
        goto L0005;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Value, &chunk->thunks, NULL)) goto L0007;
        goto L0005;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NestedExpr, &chunk->thunks, NULL)) goto L0008;
        goto L0005;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ellipsis, &chunk->thunks, NULL)) goto L0009;
        goto L0005;
    L0009:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0005:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Cast(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NestedExpr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MethodReference(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != ':' ||
        (ctx->buffer.buf + ctx->pos)[1] != ':'
    ) goto L0000;
    ctx->pos += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Value(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ObjConstruction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArrayConstruction, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TupleConstruction, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Lambda, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Iterable, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralValue, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Invoke, &chunk->thunks, NULL)) goto L0009;
            if (ctx->pos == p) break;
            continue;
        L0009:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PostfixOps, &chunk->thunks, NULL)) goto L0010;
        goto L0011;
    L0010:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0011:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralValue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NumLiteral, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CharLiteral, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StringLiteral, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Index(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LSqB, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RSqB, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Lambda(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SingleParamLambda, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiparamLambda, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Ellipsis, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0005:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0007;
        goto L0006;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MethodBlockBody, &chunk->thunks, NULL)) goto L0008;
        goto L0006;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0006:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SingleParamLambda(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p0 = ctx->pos;
        const int n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->pos = p0;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
            goto L0000;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiparamLambda(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CallParameters, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CallParameters(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeArguments, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedCallParameters, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnonymousCallParameters, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedCallParameters(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedAssignmentList, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnonymousCallParameters(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LP, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExpressionList, &chunk->thunks, NULL)) goto L0001;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OptionalEllipsis, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RP, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjConstruction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ObjConstructionBody, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjConstructionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockStart, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ValueReference, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedAssignmentList, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlockEnd, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedAssignmentList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedAssignment, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedAssignment, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedAssignment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '='
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ValueReference(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Invoke, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitOr, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayConstruction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LSqB, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArrayElements, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RSqB, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArrayElements(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExpressionList, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Iterable(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comprehension, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OpenRange, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OpenRange(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NumLiteral, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '.' ||
        (ctx->buffer.buf + ctx->pos)[1] != '.'
    ) goto L0000;
    ctx->pos += 2;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NumLiteral, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comprehension(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LSqB, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedRange, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comma, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitOr, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamedRange, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ComprPipeline, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RSqB, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamedRange(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Name, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Colon, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OpenRange, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ComprPipeline(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Arrow, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0000;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BitOr, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Expression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SumOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '+'
        ) goto L0002;
        ctx->pos++;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '-'
        ) goto L0003;
        ctx->pos++;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MulOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '*'
        ) goto L0002;
        ctx->pos++;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '/'
        ) goto L0003;
        ctx->pos++;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '%'
        ) goto L0004;
        ctx->pos++;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '-'
        ) goto L0002;
        ctx->pos++;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '+'
        ) goto L0003;
        ctx->pos++;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '-' ||
            (ctx->buffer.buf + ctx->pos)[1] != '-'
        ) goto L0004;
        ctx->pos += 2;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '+' ||
            (ctx->buffer.buf + ctx->pos)[1] != '+'
        ) goto L0005;
        ctx->pos += 2;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '!'
        ) goto L0006;
        ctx->pos++;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '~'
        ) goto L0007;
        ctx->pos++;
        goto L0001;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PostfixOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '-' ||
            (ctx->buffer.buf + ctx->pos)[1] != '-'
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '+' ||
            (ctx->buffer.buf + ctx->pos)[1] != '+'
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '+' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '-' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '^' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0004;
        ctx->pos += 2;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '|' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0005;
        ctx->pos += 2;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '&' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0006;
        ctx->pos += 2;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '='
        ) goto L0007;
        ctx->pos++;
        goto L0001;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '=' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '!' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CompareOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '<' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '>' ||
            (ctx->buffer.buf + ctx->pos)[1] != '='
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '<'
        ) goto L0004;
        ctx->pos++;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '>'
        ) goto L0005;
        ctx->pos++;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ShiftOps(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '<' ||
            (ctx->buffer.buf + ctx->pos)[1] != '<'
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '>' ||
            (ctx->buffer.buf + ctx->pos)[1] != '>'
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != '>' ||
            (ctx->buffer.buf + ctx->pos)[1] != '>' ||
            (ctx->buffer.buf + ctx->pos)[2] != '>'
        ) goto L0004;
        ctx->pos += 3;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BasedNumLiteral, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NumSuffix, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0002:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BasedNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_HexNumLiteral, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OctNumLiteral, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BinNumLiteral, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FloatNumLiteral, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecNumLiteral, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_HexNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '0' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'x'
    ) goto L0000;
    ctx->pos += 2;
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(
            (c >= '0' && c <= '9') ||
            (c >= 'a' && c <= 'f') ||
            (c >= 'A' && c <= 'F')
        )) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    (c >= '0' && c <= '9') ||
                    (c >= 'a' && c <= 'f') ||
                    (c >= 'A' && c <= 'F') ||
                    c == '_'
                )) goto L0001;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OctNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '0' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'o'
    ) goto L0000;
    ctx->pos += 2;
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(c >= '0' && c <= '7')) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    (c >= '0' && c <= '7') ||
                    c == '_'
                )) goto L0001;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BinNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '0' ||
        (ctx->buffer.buf + ctx->pos)[1] != 'b'
    ) goto L0000;
    ctx->pos += 2;
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(
            c == '0' ||
            c == '1'
        )) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    c == '0' ||
                    c == '1' ||
                    c == '_'
                )) goto L0001;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FloatNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecSegment, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '.'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecSegment, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->pos] != 'e'
            ) goto L0003;
            ctx->pos++;
            goto L0002;
        L0003:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->pos] != 'E'
            ) goto L0004;
            ctx->pos++;
            goto L0002;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.buf[ctx->pos] != '+'
                ) goto L0007;
                ctx->pos++;
                goto L0006;
            L0007:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                if (
                    pcc_refill_buffer(ctx, 1) < 1 ||
                    ctx->buffer.buf[ctx->pos] != '-'
                ) goto L0008;
                ctx->pos++;
                goto L0006;
            L0008:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0005;
            L0006:;
            }
            goto L0009;
        L0005:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        L0009:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecSegment, &chunk->thunks, NULL)) goto L0001;
        goto L0010;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0010:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DecNumLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecSegment, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DecSegment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(c >= '0' && c <= '9')) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    (c >= '0' && c <= '9') ||
                    c == '_'
                )) goto L0001;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NumSuffix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
            (ctx->buffer.buf + ctx->pos)[1] != '8'
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
            (ctx->buffer.buf + ctx->pos)[1] != '8'
        ) goto L0003;
        ctx->pos += 2;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
            (ctx->buffer.buf + ctx->pos)[1] != '1' ||
            (ctx->buffer.buf + ctx->pos)[2] != '6'
        ) goto L0004;
        ctx->pos += 3;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
            (ctx->buffer.buf + ctx->pos)[1] != '1' ||
            (ctx->buffer.buf + ctx->pos)[2] != '6'
        ) goto L0005;
        ctx->pos += 3;
        goto L0001;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
            (ctx->buffer.buf + ctx->pos)[1] != '3' ||
            (ctx->buffer.buf + ctx->pos)[2] != '2'
        ) goto L0006;
        ctx->pos += 3;
        goto L0001;
    L0006:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
            (ctx->buffer.buf + ctx->pos)[1] != '3' ||
            (ctx->buffer.buf + ctx->pos)[2] != '2'
        ) goto L0007;
        ctx->pos += 3;
        goto L0001;
    L0007:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'i' ||
            (ctx->buffer.buf + ctx->pos)[1] != '6' ||
            (ctx->buffer.buf + ctx->pos)[2] != '4'
        ) goto L0008;
        ctx->pos += 3;
        goto L0001;
    L0008:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'u' ||
            (ctx->buffer.buf + ctx->pos)[1] != '6' ||
            (ctx->buffer.buf + ctx->pos)[2] != '4'
        ) goto L0009;
        ctx->pos += 3;
        goto L0001;
    L0009:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'f' ||
            (ctx->buffer.buf + ctx->pos)[1] != '1' ||
            (ctx->buffer.buf + ctx->pos)[2] != '6'
        ) goto L0010;
        ctx->pos += 3;
        goto L0001;
    L0010:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'f' ||
            (ctx->buffer.buf + ctx->pos)[1] != '3' ||
            (ctx->buffer.buf + ctx->pos)[2] != '2'
        ) goto L0011;
        ctx->pos += 3;
        goto L0001;
    L0011:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 3) < 3 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'f' ||
            (ctx->buffer.buf + ctx->pos)[1] != '6' ||
            (ctx->buffer.buf + ctx->pos)[2] != '4'
        ) goto L0012;
        ctx->pos += 3;
        goto L0001;
    L0012:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_QualifiedName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'F' ||
            (ctx->buffer.buf + ctx->pos)[1] != '\"'
        ) goto L0001;
        ctx->pos += 2;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    }
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(
            c == '_' ||
            c == '$' ||
            c == '@' ||
            (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z')
        )) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0002;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    c == '_' ||
                    c == '$' ||
                    c == '.' ||
                    (c >= 'a' && c <= 'z') ||
                    (c >= 'A' && c <= 'Z') ||
                    (c >= '0' && c <= '9')
                )) goto L0002;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Name(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != 'F' ||
            (ctx->buffer.buf + ctx->pos)[1] != '\"'
        ) goto L0001;
        ctx->pos += 2;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    }
    {
        char c;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0000;
        c = ctx->buffer.buf[ctx->pos];
        if (!(
            c == '_' ||
            c == '$' ||
            c == '@' ||
            (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z')
        )) goto L0000;
        ctx->pos++;
    }
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0002;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    c == '_' ||
                    c == '$' ||
                    (c >= 'a' && c <= 'z') ||
                    (c >= 'A' && c <= 'Z') ||
                    (c >= '0' && c <= '9')
                )) goto L0002;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0002:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CharLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '\''
    ) goto L0000;
    ctx->pos++;
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '\''
        ) goto L0002;
        ctx->pos++;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->pos] != '\''
            ) goto L0004;
            ctx->pos++;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            goto L0003;
        L0004:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        }
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0003;
        ctx->pos++;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '\''
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StringLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterpolatedStringLiteral, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        {
            const int p0 = ctx->pos;
            const int n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StringSegment, &chunk->thunks, NULL)) goto L0004;
                if (ctx->pos == p) break;
                continue;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->pos = p0;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n0);
                goto L0003;
            }
        }
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StringSegment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '\"'
    ) goto L0000;
    ctx->pos++;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (
                    pcc_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->pos)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->pos)[1] != '\"'
                ) goto L0003;
                ctx->pos += 2;
                goto L0002;
            L0003:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                {
                    const int p = ctx->pos;
                    const int n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->pos] != '\"'
                    ) goto L0005;
                    ctx->pos++;
                    ctx->pos = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0004;
                L0005:;
                    ctx->pos = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0004;
                ctx->pos++;
                goto L0002;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '\"'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterpolatedStringLiteral(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != 'F' ||
        (ctx->buffer.buf + ctx->pos)[1] != '\"'
    ) goto L0000;
    ctx->pos += 2;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (
                    pcc_refill_buffer(ctx, 2) < 2 ||
                    (ctx->buffer.buf + ctx->pos)[0] != '\\' ||
                    (ctx->buffer.buf + ctx->pos)[1] != '\"'
                ) goto L0003;
                ctx->pos += 2;
                goto L0002;
            L0003:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                {
                    const int p = ctx->pos;
                    const int n = chunk->thunks.len;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 ||
                        ctx->buffer.buf[ctx->pos] != '\"'
                    ) goto L0005;
                    ctx->pos++;
                    ctx->pos = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                    goto L0004;
                L0005:;
                    ctx->pos = p;
                    pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                }
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0004;
                ctx->pos++;
                goto L0002;
            L0004:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '\"'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Semicolon(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != ';'
    ) goto L0000;
    ctx->pos++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Ellipsis(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 3) < 3 ||
        (ctx->buffer.buf + ctx->pos)[0] != '.' ||
        (ctx->buffer.buf + ctx->pos)[1] != '.' ||
        (ctx->buffer.buf + ctx->pos)[2] != '.'
    ) goto L0000;
    ctx->pos += 3;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Arrow(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '-' ||
        (ctx->buffer.buf + ctx->pos)[1] != '>'
    ) goto L0000;
    ctx->pos += 2;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LogicalAnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '&' ||
        (ctx->buffer.buf + ctx->pos)[1] != '&'
    ) goto L0000;
    ctx->pos += 2;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LogicalOr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '|' ||
        (ctx->buffer.buf + ctx->pos)[1] != '|'
    ) goto L0000;
    ctx->pos += 2;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitAnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '&'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitOr(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '|'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BitXor(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '^'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comma(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != ','
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BlockStart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '{'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BlockEnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '}'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '('
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != ')'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LSqB(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != '['
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RSqB(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != ']'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Colon(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0000;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->pos] != ':'
    ) goto L0000;
    ctx->pos++;
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule___(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                char c;
                if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
                c = ctx->buffer.buf[ctx->pos];
                if (!(
                    c == ' ' ||
                    c == '\t' ||
                    c == '\r' ||
                    c == '\n'
                )) goto L0001;
                ctx->pos++;
            }
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0003:;
    }
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    if (
        pcc_refill_buffer(ctx, 2) < 2 ||
        (ctx->buffer.buf + ctx->pos)[0] != '/' ||
        (ctx->buffer.buf + ctx->pos)[1] != '/'
    ) goto L0000;
    ctx->pos += 2;
    {
        int i;
        for (i = 0;; i++) {
            const int p = ctx->pos;
            const int n = chunk->thunks.len;
            {
                const int p = ctx->pos;
                const int n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_end, &chunk->thunks, NULL)) goto L0002;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
                goto L0001;
            L0002:;
                ctx->pos = p;
                pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            }
            if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
            ctx->pos++;
            if (ctx->pos == p) break;
            continue;
        L0001:;
            ctx->pos = p;
            pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
            break;
        }
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_end, &chunk->thunks, NULL)) goto L0003;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0004;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0004:;
    }
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule___, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    L0006:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_end(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_eol, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_eof, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_eol(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 2) < 2 ||
            (ctx->buffer.buf + ctx->pos)[0] != '\r' ||
            (ctx->buffer.buf + ctx->pos)[1] != '\n'
        ) goto L0002;
        ctx->pos += 2;
        goto L0001;
    L0002:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '\n'
        ) goto L0003;
        ctx->pos++;
        goto L0001;
    L0003:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->pos] != '\r'
        ) goto L0004;
        ctx->pos++;
        goto L0001;
    L0004:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_eof(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx->auxil);
    chunk->pos = ctx->pos;
    pcc_value_table__resize(ctx->auxil, &chunk->values, 0);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 0);
    {
        const int p = ctx->pos;
        const int n = chunk->thunks.len;
        if (pcc_refill_buffer(ctx, 1) < 1) goto L0001;
        ctx->pos++;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
        goto L0000;
    L0001:;
        ctx->pos = p;
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, n);
    }
    return chunk;
L0000:;
    pcc_thunk_chunk__destroy(ctx->auxil, chunk);
    return NULL;
}

pcc_context_t *pcc_create(void *auxil) {
    return pcc_context__create(auxil);
}

int pcc_parse(pcc_context_t *ctx, int *ret) {
    pcc_thunk_array_t thunks;
    pcc_thunk_array__init(ctx->auxil, &thunks, PCC_ARRAYSIZE);
    if (pcc_apply_rule(ctx, pcc_evaluate_rule_Program, &thunks, ret))
        pcc_do_action(ctx, &thunks, ret);
    else
        PCC_ERROR(ctx->auxil);
    pcc_commit_buffer(ctx);
    pcc_thunk_array__term(ctx->auxil, &thunks);
    return pcc_refill_buffer(ctx, 1) >= 1;
}

void pcc_destroy(pcc_context_t *ctx) {
    pcc_context__destroy(ctx);
}
