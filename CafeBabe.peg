Program <- Use* Constant* Type* Extension* Function* Unsafe*

Use <- _ 'use' QualifiedName ImportList? Semicolon
Constant <- Public? _ 'const' (KW_val / TypeName) Name Eq Expression Semicolon
Type <- AnnotationRef* Public? KW_type TypeName Eq (ApiDecl / AnnotationDecl / TypeAliasDecl / CompoundTypeDecl / TupleDecl / ClassDecl)
Extension <- Public? _ 'extend' TypeName ApiRefs? ClassBlock
Function <- AnnotationRef* Public? MethodSignature MethodBody
Unsafe <- _ 'unsafe' BlockStart Constant* Type* Function* BlockEnd

ImportList <- BlockStart NameWithAlias (Comma NameWithAlias)* BlockEnd
NameWithAlias <- Name (_ 'as'  Name)?
AnnotationRef <- _ '@' Name (LP Expression? (Comma Expression)* RP)?

TupleDecl <- LP TypeName? (Comma TypeName)* (Comma Ellipsis)? RP Semicolon
ApiDecl <- _ 'api' CommonApiBody
TypeAliasDecl <- ArgumentType Semicolon

AnnotationDecl <- (KW_type / KW_fn) _ 'annotation' DataDecl BlockStart Statement* BlockEnd

CompoundTypeDecl <- TypeName ( AndType / OrType)? (Semicolon / CommonApiDecl)
AndType <- (Comma TypeName)+
OrType <- (BitOr TypeName)+

CommonApiDecl <- ApiRefs? CommonApiBody
ApiRefs <- Colon TypeNameList

CommonApiBody <- BlockStart Constant* ((MethodSignature Semicolon) / StaticMethodImpl)* NamedClassDecl* BlockEnd

MethodSignature <- TypeVarsDecl? (TypedFunction/UntypedFunction)
TypedFunction <- TypeName Name LP TypedArgList? RP
UntypedFunction <- KW_fn Name OptionalNameList
OptionalNameList <- LP NameList? RP
ClassDecl <- KW_class DataDecl? ApiRefs? (ClassBlock / Semicolon)

NamedClassDecl <- Public? KW_class TypeName ClassBody
ClassBody <- DataDecl? ApiRefs? ClassBlock
DataDecl <- LP TypedArgList RP
ClassBlock <- BlockStart Constant* Constructor* Destructor? (StaticMethodImpl / Function / MethodImpl)* NamedClassDecl* BlockEnd
StaticMethodImpl <- Public? _ 'static' MethodSignature MethodBody
Constructor <- Public? Name LP TypedArgList? RP MethodBody
Destructor <- Public? _ '#' Name LP RP MethodBody
Public <- _ 'pub'

MethodImpl <- _ 'impl' Name OptionalNameList MethodBody
MethodBody <- MethodExpression / MethodBlockBody
MethodExpression <- Eq Expression Semicolon

MethodBlockBody <- BlockStart Statement* BlockEnd
Statement <- (ForStatement / IfExpression / SelectExpression / MatchExpression / ReturnStatement / VariableDeclaration / Assignment / IterableStatement / MethodBlockBody / ValueStatement)
ValueStatement <- Value Semicolon
VariableDeclaration <- VarTitle Assignment
VarTitle <- KW_val / KW_var / TypeName
Assignment <- AssignmentExpr Semicolon
AssignmentExpr <- RegularAssignment / ParallelAssignment
RegularAssignment <- QualifiedName AssignOps Expression
ParallelAssignment <- RequiredNameList Eq (TupleConstruction / Expression)
TupleConstruction <- LP Expression? (Comma Expression)* (Comma Ellipsis)? RP
RequiredNameList <- LP NameList RP
ForStatement <- KW_for LP VarTitle Name Colon Expression RP MethodBlockBody
ReturnStatement <- KW_return Expression? Semicolon
IterableStatement <- Iterable RefChain* Semicolon
RefChain <- CallParameters / MethodCall / Index
MethodCall <- Dot QualifiedName RefChain?

TypeName <- Name TypeArguments? BitAnd? ArrayDecl*
ArrayDecl <- LSqB RSqB
TypeArguments <- LT TypeNameList (Comma Ellipsis)? GT
TypeVarsDecl <- LT LimitedTypeName (Comma LimitedTypeName)* GT
LimitedTypeName <- Name (Colon TypeName ('+'/'-')?)?
TypeNameList <- TypeName (Comma TypeName)*
TypedArgList <- TypedArgument (Comma TypedArgument)* (Comma Ellipsis)?
TypedArgument <- ArgumentType Name
ArgumentType <- TypeName (Arrow Ellipsis? TypeName)*

NameList <- Name (Comma Name)*

Expression <- IfExpression / SelectExpression / MatchExpression / TernaryExpression / _ 'break' / _ 'continue' / Expr

IfExpression <- KW_if BooleanExpression MethodBlockBody (KW_else MethodBlockBody)?
SelectExpression <- KW_select NestedExpr BlockStart SelectCase* Default? BlockEnd
MatchExpression <- KW_match NestedExpr BlockStart MatchCase* Default? BlockEnd
TernaryExpression <- NestedExpr QuestMark Expression Colon Expression
BooleanExpression <- LP Expr RP
SelectCase <- KW_case CaseExpr Arrow Expression Semicolon
MatchCase <- TypeName Arrow Expression Semicolon
Default <- KW_default Arrow Expression Semicolon
CaseExpr <- (NumLiteral / StringLiteral / Iterable / ObjConstruction)

Expr <- Or (LogicalOr Or)*
Or <- And (LogicalAnd And)*
And <- BitwiseOr (BitOr BitwiseOr)*
BitwiseOr <- BitwiseXor (BitXor BitwiseXor)*
BitwiseXor <- BitwiseAnd (BitAnd BitwiseAnd)*
BitwiseAnd <- Equality (EqualityOps Equality)*
Equality <- Compare (CompareOps Compare)*
Compare <- Shift (ShiftOps Shift)*
Shift <- Sum (SumOps Sum)*
Sum <- Product (MulOps Product)*
Product <- (Cast / UnaryOps)* (MethodReference / Value / NestedExpr / Ellipsis)
Cast <- LP TypeName RP
MethodReference <- QualifiedName? DoubleColon Name

Value <- LiteralValue RefChain* PostfixOps?
LiteralValue <-  Lambda / QualifiedName / NumLiteral / CharLiteral / StringLiteral / Iterable / ObjConstruction / ArrayConstruction / TupleConstruction
Index <- LSqB Expression RSqB
Lambda <- (TypeName? CallParameters / Name) Arrow Ellipsis? (Expression / MethodBlockBody)
CallParameters <- LP (Expression (Comma Expression)* (Comma Ellipsis)?)? RP
NestedExpr <- LP Expression RP
ObjConstruction <- TypeName? BlockStart (Expression BitOr)? AssignmentExpr (Comma AssignmentExpr)* BlockEnd
ArrayConstruction <- BlockStart (Expression (Comma Expression)*)? BlockEnd

Iterable <- Comprehension / OpenRange
OpenRange <- LSqB NumLiteral SequenceSign NumLiteral? (Comma NumLiteral)? RSqB

Comprehension <- LSqB NamedRange ((Comma / LogicalOr) NamedRange)* Colon (NestedExpr Colon)? TupleConstruction RSqB
NamedRange <- OpenRange Arrow Name

SumOps <- _ < ('+'/'-') >
MulOps <- _ < ('*' / '/' / '%') >
UnaryOps <- _ < ('-' / '+' / '--' / '++' / '!' / '~') >
PostfixOps <- _ < ('--' / '++') >
AssignOps <- _ < (Eq / '+=' / '-=' / '^=' / '|=' / '&=' ) >
EqualityOps <- _ < ('==' / '!=') >
CompareOps <- _ < ('<=' / '>=' / LT / GT / KW_isA) >
ShiftOps <- _ < ('<<' / '>>' / '>>>') >

NumLiteral <- (HexNumLiteral / OctNumLiteral / BinNumLiteral / FloatNumLiteral / DecNumLiteral) NumSuffix?

HexNumLiteral <- _ <'0x' [0-9a-fA-F] [0-9a-fA-F_]* > _
OctNumLiteral <- _ <'0o' [0-7] [0-7_]* > _
BinNumLiteral <- _ <'0b' [01] [01_]* > _
FloatNumLiteral <- _ < DecSegment _ '.' DecSegment _ (('e'/'E') _ ('+' / '-')? DecSegment _)? > _
DecNumLiteral <- _ <DecSegment> _
DecSegment <- [0-9][0-9_]*

NumSuffix <- 'i8' / 'u8' / 'i16' / 'u16' / 'i32' / 'u32' / 'i64' / 'u64' / 'f16' / 'f32' / 'f64'

QualifiedName <- _ <!('R' '"' '(') [_$@a-zA-Z] [_$.a-zA-Z0-9]*> _
Name <- _ <!('R' '"' '(') [_$@a-zA-Z] [_$a-zA-Z0-9]*> _

KW_case <- _ 'case'
KW_class <- _ 'class'
KW_default <- _ 'default'
KW_else <- _ 'else'
KW_fn <- _ 'fn'
KW_for <- _ 'for'
KW_if <- _ 'if'
KW_isA <- _ 'isA'
KW_match <- _ 'match'
KW_return <- _ 'return'
KW_select <- _ 'select'
KW_type <- _ 'type'
KW_val <- _ 'val' _
KW_var <- _ 'var'

CharLiteral <- _ < [\'] < ('\'' / ![\'] .) > [\'] > _

StringLiteral <- RawStringLiteral / StringSegment+
StringSegment <- _ < ["] < ('\\"' / !["] .)* > ["] > _
RawStringLiteral <- _ < 'R' '"' '(' < (!(<')' '"'>) .)* > ')' '"' > _

Semicolon <- _ ';' _
Ellipsis <- _ '...'
Arrow <- _ < '->' >
LogicalAnd <- _ '&&'
LogicalOr <- _ '||'
BitAnd <- _ '&'
BitOr <- _ '|'
BitXor <- _ '^'
Comma <- _ ','
BlockStart <- _ '{'
BlockEnd <- _ '}' _
SequenceSign <- _ '..'
LP <- _ '('
RP <- _ ')'
LSqB <- _ '['
RSqB <- _ ']'
Dot <- _ '.'
Colon <- _ ':'
DoubleColon <- _ <'::' > _
Eq <- _ '='
LT <- _ '<'
GT <- _ '>'
QuestMark <- _ '?' _
~_ <- [ \t\r\n]* Comment?
Comment <- '//' (!End .)* &End _?
End <- Eol / Eof
Eol <- '\r\n' / '\n' / '\r'
Eof <- !.
