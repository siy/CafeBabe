Program <- Use* Constant* Type* Extension* Function* Unsafe*

Use <- _ 'use' PackageName ImportList? Semicolon
Constant <- AccessModifier? _ 'const' (KW_val / TypeName) Name Eq Expression Semicolon
Type <- AnnotationRef* AccessModifier? KW_type TypeName Eq (ApiDecl / AnnotationDecl / CompoundTypeDecl / TupleDecl / TypeAliasDecl / ClassDecl)
Extension <- AccessModifier? _ 'extend' TypeName ApiRefs? ClassBlock
Function <- AnnotationRef* AccessModifier? MethodSignature MethodBody
Unsafe <- _ 'unsafe' BlockStart Constant* Type* Function* BlockEnd

PackageName <- Name (Dot Name )*
ImportList <- BlockStart NameWithAlias (Comma NameWithAlias)* BlockEnd
NameWithAlias <- Name (_ 'as'  Name)?
AnnotationRef <- At Name (LP Expression? (Comma Expression)* RP)?

TupleDecl <- LP TypeName? (Comma TypeName)* (Comma Ellipsis)? RP Semicolon
ApiDecl <- _ 'api' CommonApiBody
TypeAliasDecl <- ArgumentType Semicolon

AnnotationDecl <- (KW_type / KW_fn) _ 'annotation' DataDecl BlockStart Statement* BlockEnd

CompoundTypeDecl <- TypeName ( AndType / OrType)? (Semicolon / CommonApiDecl)
AndType <- (Comma TypeName)+
OrType <- (BitOr TypeName)+

CommonApiDecl <- ApiRefs? CommonApiBody
ApiRefs <- Colon TypeNameList

CommonApiBody <- BlockStart Constant* (MethodDecl / StaticMethodImpl)* NamedClassDecl* BlockEnd

MethodDecl <- MethodSignature Semicolon

MethodSignature <- TypeVarsDecl? (TypedFunction/UntypedFunction)
TypedFunction <- TypeName Name LP TypedArgList? RP 
UntypedFunction <- KW_fn Name OptionalNameList
OptionalNameList <- LP NameList? RP
ClassDecl <- KW_class ClassBody

NamedClassDecl <- AccessModifier? KW_class TypeName ClassBody
ClassBody <- DataDecl? ApiRefs? ClassBlock
DataDecl <- LP TypedArgList RP
ClassBlock <- BlockStart Constant* (StaticMethodImpl / Function / MethodImpl)* NamedClassDecl* BlockEnd
StaticMethodImpl <- AccessModifier? _ 'static' MethodSignature MethodBody

AccessModifier <- _ 'pub'

MethodImpl <- _ 'impl' Name OptionalNameList MethodBody
MethodBody <- MethodExpression / MethodBlockBody
MethodExpression <- Eq Expression Semicolon

MethodBlockBody <- BlockStart Statement* BlockEnd
Statement <- (ForStatement / IfExpression / SelectExpression / MatchExpression / ReturnStatement / VariableDeclaration / Assignment / IterableStatement / MethodBlockBody / ValueStatement)
ValueStatement <- Value Semicolon
VariableDeclaration <- VarTitle Assignment
VarTitle <- KW_val / KW_var / TypeName
Assignment <- AssignmentExpr Semicolon
AssignmentExpr <- RegularAssignment / ParallelAssignment
RegularAssignment <- Name AssignOps Expression
ParallelAssignment <- RequiredNameList Eq (TupleConstruction / Expression)
TupleConstruction <- LP Expression? (Comma Expression)* (Comma Ellipsis)? RP
RequiredNameList <- LP NameList RP
ForStatement <- KW_for LP VarTitle Name Colon Expression RP MethodBlockBody
ReturnStatement <- KW_return Expression? Semicolon
IterableStatement <- Iterable MethodCall? Semicolon

TypeName <- Name TypeArguments? BitAnd? ArrayDecl*
ArrayDecl <- LSqB RSqB
TypeArguments <- LT TypeNameList (Comma Ellipsis)? GT
TypeVarsDecl <- LT LimitedTypeName (Comma LimitedTypeName)* GT
LimitedTypeName <- Name (Colon TypeName ('+'/'-')?)?
TypeNameList <- TypeName (Comma TypeName)*
TypedArgList <- TypedArgument (Comma TypedArgument)* (Comma Ellipsis)?
TypedArgument <- ArgumentType Name
ArgumentType <- TypeName (Arrow Ellipsis? TypeName)*

NameList <- Name (Comma Name)*

Expression <- IfExpression / SelectExpression / MatchExpression / TernaryExpression / KW_break / KW_continue / Expr

IfExpression <- KW_if NestedExpr MethodBlockBody (KW_else MethodBlockBody)?
SelectExpression <- KW_select NestedExpr BlockStart SelectCase* Default? BlockEnd
MatchExpression <- KW_match NestedExpr BlockStart MatchCase* Default? BlockEnd
TernaryExpression <- NestedExpr _ '?' Expression Colon Expression

SelectCase <- KW_case CaseExpr Arrow Expression Semicolon
MatchCase <- TypeName Arrow Expression Semicolon
Default <- KW_default Arrow Expression Semicolon
CaseExpr <- (NumLiteral / StringLiteral / Iterable / ObjConstruction)

Expr <- Or (LogicalOr Or)*
Or <- And (LogicalAnd And)*
And <- BitwiseOr (BitOr BitwiseOr)*
BitwiseOr <- BitwiseXor (BitXor BitwiseXor)*
BitwiseXor <- BitwiseAnd (BitAnd BitwiseAnd)*
BitwiseAnd <- Equality (EqualityOps Equality)*
Equality <- Compare (CompareOps Compare)*
Compare <- Shift (ShiftOps Shift)*
Shift <- Sum (SumOps Sum)*
Sum <- Product (MulOps Product)*
Product <- ((Cast / UnaryOps)* UnaryValue)
UnaryValue <- (Value / NestedExpr / Ellipsis) PostfixOps?
Cast <- LP TypeName RP
Value <- LiteralValue Call?
LiteralValue <- NumLiteral / StringLiteral / Iterable / ObjConstruction / ArrayConstruction / TupleConstruction / Lambda / (Name !Ellipsis)
Call <- (MethodReference / MethodCall / CallParameters / Name / Index)*
Index <- LSqB Expression RSqB
MethodReference <- Colon Name
MethodCall <- Dot Name Call
Lambda <- (TypeName? CallParameters / Name) Arrow Ellipsis? (Expression / MethodBlockBody)
NestedExpr <- LP Expression RP 
ObjConstruction <- TypeName? BlockStart (Expression BitOr)? AssignmentExpr (Comma AssignmentExpr)* BlockEnd
ArrayConstruction <- LSqB (Expression (Comma Expression)*)? RSqB

Iterable <- Range / Comprehension
Range <- LSqB NumLiteral SequenceSign NumLiteral (Comma NumLiteral)? RSqB
OpenRange <- LSqB NumLiteral SequenceSign (NumLiteral (Comma NumLiteral)?)? RSqB
Comprehension <- LSqB Expr BitOr Name LeftArrow OpenRange (ProductCompr / ParallelCompr) (OutputCondition)?RSqB
ProductCompr <- (Comma Name LeftArrow OpenRange)*
ParallelCompr <- (BitOr Name LeftArrow OpenRange)*
OutputCondition <- Comma Expression
CallParameters <- LP (Expression (Comma Expression)* (Comma Ellipsis)?)? RP

SumOps <- _ < ('+'/'-') >
MulOps <- _ < ('*' / '/' / '%') >
UnaryOps <- _ < ('-' / '+' / '--' / '++' / '!' / '~') >
PostfixOps <- _ < ('--' / '++') >
AssignOps <- _ < (Eq / '+=' / '-=' / '^=' / '|=' / '&=' ) >
EqualityOps <- _ < ('==' / '!=') >
CompareOps <- _ < ('<=' / '>=' / LT / GT / KW_isA) >
ShiftOps <- _ < ('<<' / '>>' / '>>>') >
NumLiteral <- _ <NumPrefix? [0-9_]+ ('.'[0-9_]+)?NumSuffix? > _
NumPrefix <- '0x' / '0b' / '0o' / '0d'
NumSuffix <- 'i8' / 'u8' / 'i16' / 'u16' / 'i32' / 'u32' / 'i64' / 'u64' / 'f16' / 'f32' / 'f64'

Name <- !Keyword NameSegment
NameSegment <- _ < [_$@a-zA-Z] [_$a-zA-Z0-9]* > _

Keyword <- KWList / NumSuffix
KWList <- _ (KW_break / KW_case / KW_continue / KW_default / KW_else / KW_for / KW_if / KW_isA / KW_match / KW_return / KW_select / KW_val / KW_var)
KW_break <- _ 'break' 
KW_case <- _ 'case' 
KW_class <- _ 'class' 
KW_continue <- _ 'continue' 
KW_default <- _ 'default' 
KW_else <- _ 'else' 
KW_fn <- _ 'fn' 
KW_for <- _ 'for' 
KW_if <- _ 'if' 
KW_isA <- _ 'isA' 
KW_match <- _ 'match' 
KW_return <- _ 'return' 
KW_select <- _ 'select' 
KW_type <- _ 'type' 
KW_val <- _ 'val' 
KW_var <- _ 'var' 

StringLiteral <- StringSegment (_ '++' StringSegment)*
StringSegment <- _ < ["] < (!["] .)* > ["] >
Semicolon <- _ ';' _
Ellipsis <- _ '...' 
Arrow <- _ '->' 
LeftArrow <- _ '<-' 
LogicalAnd <- _ '&&' 
LogicalOr <- _ '||' 
BitAnd <- _ '&' 
BitOr <- _ '|' 
BitXor <- _ '^' 
Comma <- _ ',' 
BlockStart <- _ '{'  
BlockEnd <- _ '}' _ 
SequenceSign <- _ '..'
LP <- _ '('
RP <- _ ')'
LSqB <- _ '['
RSqB <- _ ']'
Dot <- _ '.'
Colon <- _ ':'
At <- _'@'
Eq <- _ '='
LT <- _ '<'
GT <- _ '>'
~_ <- [ \t\r\n]* Comment?
Comment <- '//' (!End .)* &End _?
End <- Eol / Eof
Eol <- '\r\n' / '\n' / '\r'
Eof <- !.
